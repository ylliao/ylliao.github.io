<!-- build time:Thu Nov 29 2018 22:48:28 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>JVM深入解析（一） | 春华秋实 - 收获喜悦</title><meta name="description" content="类加载在Java代码中，类的加载、连接与初始化过程都是在程序运行期间完成的；类型的加载：最常见的情况，将已经编写好的、编译完成的class文件，从磁盘里加载到内存里；连接：将类与类之间的关系给确定好，并且对于字节码一些相关的处理，一些验证（校验）在相应的加载连接阶段完成，类与类之间的调用关系也是在此阶段完成，典型的是将类与类之间的这种符号引用转换成一个直接引用也是在此阶段完成；初始化过程：就是对于"><meta name="keywords" content="JVM"><meta property="og:type" content="article"><meta property="og:title" content="JVM深入解析（一）"><meta property="og:url" content="http://www.ylliao.club/2018/11/29/JVM深入解析/index.html"><meta property="og:site_name" content="春华秋实"><meta property="og:description" content="类加载在Java代码中，类的加载、连接与初始化过程都是在程序运行期间完成的；类型的加载：最常见的情况，将已经编写好的、编译完成的class文件，从磁盘里加载到内存里；连接：将类与类之间的关系给确定好，并且对于字节码一些相关的处理，一些验证（校验）在相应的加载连接阶段完成，类与类之间的调用关系也是在此阶段完成，典型的是将类与类之间的这种符号引用转换成一个直接引用也是在此阶段完成；初始化过程：就是对于"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.ylliao.club/2018/11/29/JVM深入解析/classLoader.png"><meta property="og:image" content="http://www.ylliao.club/2018/11/29/JVM深入解析/entrust.png"><meta property="og:updated_time" content="2018-11-29T12:09:00.724Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM深入解析（一）"><meta name="twitter:description" content="类加载在Java代码中，类的加载、连接与初始化过程都是在程序运行期间完成的；类型的加载：最常见的情况，将已经编写好的、编译完成的class文件，从磁盘里加载到内存里；连接：将类与类之间的关系给确定好，并且对于字节码一些相关的处理，一些验证（校验）在相应的加载连接阶段完成，类与类之间的调用关系也是在此阶段完成，典型的是将类与类之间的这种符号引用转换成一个直接引用也是在此阶段完成；初始化过程：就是对于"><meta name="twitter:image" content="http://www.ylliao.club/2018/11/29/JVM深入解析/classLoader.png"><link rel="canonical" href="http://www.ylliao.club/2018/11/29/JVM深入解析/index.html"><link rel="alternate" href="/atom.xml" title="春华秋实" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/ylliao" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">廖月礼</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">一份耕耘，一份收获</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Wuhan, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech=""> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/ylliao" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/ylliao" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!<br>相互学习，共同成长！</p></div></div></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/JVM/" style="font-size:13px">JVM</a> <a href="/tags/Kafka/" style="font-size:13px">Kafka</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">3</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/2018/11/29/JVM深入解析/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/11/29/JVM深入解析/" class="title">JVM深入解析（一）</a></p><p class="item-date"><time datetime="2018-11-29T11:59:53.000Z" itemprop="datePublished">2018-11-29</time></p></div></li><li><div class="item-thumb"><a href="/2018/11/27/Apache-Kafka实战剖析/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/11/27/Apache-Kafka实战剖析/" class="title">Apache Kafka实战剖析（一）</a></p><p class="item-date"><time datetime="2018-11-27T15:33:04.000Z" itemprop="datePublished">2018-11-27</time></p></div></li><li><div class="item-thumb"><a href="/2018/11/26/关于本博客的搭建与应用/" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/11/26/关于本博客的搭建与应用/" class="title">关于本博客的搭建与应用</a></p><p class="item-date"><time datetime="2018-11-26T12:58:50.000Z" itemprop="datePublished">2018-11-26</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-JVM深入解析" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">JVM深入解析（一）</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2018/11/29/JVM深入解析/" class="article-date"><time datetime="2018-11-29T11:59:53.000Z" itemprop="datePublished">2018-11-29</time></a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/JVM/">JVM</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/11/29/JVM深入解析/#comments" class="article-comment-link">评论</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><ol><li><p>在Java代码中，类的加载、连接与初始化过程都是在程序运行期间完成的；</p><ul><li>类型的加载：最常见的情况，将已经编写好的、编译完成的class文件，从磁盘里加载到内存里；</li><li>连接：将类与类之间的关系给确定好，并且对于字节码一些相关的处理，一些验证（校验）在相应的加载连接阶段完成，类与类之间的调用关系也是在此阶段完成，典型的是将类与类之间的这种符号引用转换成一个直接引用也是在此阶段完成；</li><li>初始化过程：就是对于一些类型里面的一些静态变量对它进行赋值，此赋值都是在此阶段完成。</li></ul></li><li><p>提供了更大的灵活性，增加了更多可能性。</p></li></ol><h4 id="类加载器深入剖析"><a href="#类加载器深入剖析" class="headerlink" title="类加载器深入剖析"></a>类加载器深入剖析</h4><p>&emsp;类加载器是类加载的工具，每一个类型都是由类加载器加载到内存中的。</p><ol><li><p>Java虚拟机与程序的生命周期；</p></li><li><p>在如下几种情况下，Java虚拟机将结束生命周期；</p><ul><li>执行了System.exit()方法，导致JVM退出；</li><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致Java虚拟机进程终止；</li></ul></li></ol><h4 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h4><ol><li><p>加载，查找并加载类的二进制数据；</p></li><li><p>连接</p><ul><li>验证：确保被加载的类的正确性；</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值；</li><li>解析：把类中的符号引用转换为直接引用；</li><li>初始化，为类的静态变量赋予正确的初始值。</li></ul></li></ol><p>如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static int a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先将Test.class加载到内存中，然后进入连接阶段；</span><br><span class="line">先验证，再为静态变量a开辟一地内存空间，将赋初始值为0；</span><br><span class="line">最后进入初始化阶段再将静态变量a赋值为声明的1。</span><br></pre></td></tr></table></figure><p></p><ol start="4"><li><p>Java程序对类的使用方式可分为两种：</p><ul><li>主动使用</li><li>被动使用</li></ul></li><li><p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们。</p></li><li><p>主动使用（七种）</p><ul><li>创建类的实例；</li><li>访问某个类或接口的静态变量（取值），或对该静态变量赋值；</li><li>调用类的静态方法，反映到字节码助记符的层面上，表示类似的含义。如：访问（读取）某个类的静态变量，在JVM层面上字节码用的是getstatic指令处理的；对于这个静态变量赋值（写入）这个变量调用的是putstatic这样的一个助记符或虚拟机字节码指令来完成对应的操作；调用类的静态方法用的是invokestatic指令处理的；</li><li>反射（如：Class.forName(“com.test.Test”)）；</li><li>初始化一个类的子类，如有两个类一个是Parent，一个是Child（Child继承Parent）,当子类Child初始化时，也会初始化Parent，是对Parent的主动使用；</li><li>Java虚拟机启动时被标明为启动类的类（Java Test）；</li><li>JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则进行初始化；</li><li>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</li></ul></li></ol><h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><ol><li><p>类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。</p></li><li><p>加载.class文件的方式</p><ul><li>从本地系统中直接加载；</li><li>通过网络下载.class文件；</li><li>从zip，jar等归档文件中加载.class文件；</li><li>从专有数据库中提取.class文件；</li><li>将Java源文件动态编译为.class文件。</li></ul></li></ol><p>示例如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author yueli.liao</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @description 1、对于静态字段来说，只有直接定义了该字段的类才会初始化</span><br><span class="line"> *               2、当一个类在初始化时，要求其父类全部都已经初始化完毕了</span><br><span class="line"> *               3、-XX:+TraceClassLoading，用于追踪类的加载信息并打印出来</span><br><span class="line"> *</span><br><span class="line"> *               JVM参数设置说明：</span><br><span class="line"> *               -XX:+&lt;option&gt;，表示开启option选项</span><br><span class="line"> *               -XX:-&lt;option&gt;，表示关闭option选项</span><br><span class="line"> *               -XX:&lt;option&gt;=&lt;value&gt;，表示将option选项的值设置为value</span><br><span class="line"> * @date Created in 2018/2/4</span><br><span class="line"> */</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(MyChild1.str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyParent1 &#123;</span><br><span class="line">   public static String str = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyChild1 extends MyParent1 &#123;</span><br><span class="line"></span><br><span class="line">   public static String str2 = &quot;welcome&quot;;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;MyChild static block&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author yueli.liao</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @description 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中；本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。</span><br><span class="line"> *               注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了；甚至，我们可以将MyParent2的class文件删除。</span><br><span class="line"> *           助记符（用javap -c 反编译后）：</span><br><span class="line"> *             ldc 表示将int，float或是String类型的常量从常量池中推送至栈顶</span><br><span class="line"> *             bipush表示将单字节（-128 - 127）的常量值推送至栈顶</span><br><span class="line"> *             sipush表示将一个短整型常量值（-32768 - 32767）推送至栈顶</span><br><span class="line"> *             iconst_1表示将int类型1推送至栈顶（iconst_1 - iconst_5）</span><br><span class="line"> * @date Created in 2018/2/4</span><br><span class="line"> */</span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(MyParent2.m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyParent2 &#123;</span><br><span class="line">   // 常量（被final修饰）在编译阶段，这个常量就会被存入到调用这个常量的那个方法所在的类的常量池当中</span><br><span class="line">   public static final String str = &quot;hello world&quot;;</span><br><span class="line">   // 用javap -c 反编译后</span><br><span class="line">   public static final short s = 127;</span><br><span class="line">   public static final int i = 128;</span><br><span class="line">   public static final int m = 5;</span><br><span class="line">   static &#123;</span><br><span class="line">      System.out.println(&quot;MyParent2 static block&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author yueli.liao</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @description 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，</span><br><span class="line"> * 				  这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。</span><br><span class="line"> * @date Created in 2018/3/25</span><br><span class="line"> */</span><br><span class="line">public class MyTest3 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(MyParent3.str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3 &#123;</span><br><span class="line">	public static final String str = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;MyParent3 static code&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author yueli.liao</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @description 对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.ssy.jvm.classloader.MyParent4</span><br><span class="line"> * 				 这种形式，动态生成的类型，其父类型就是Object。</span><br><span class="line"> * 				 对于数组来说，JavaDoc经常将构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。</span><br><span class="line"> * 				 助记符：</span><br><span class="line"> * 				 anewarray：表示创建一个引用类型（如类、接口、数组）的数组，并将其引用值压入栈顶；</span><br><span class="line"> * 				 newarray：表示创建一个指定的原始类型（如int、float、double等）的数组，并将其引用值压入栈顶。</span><br><span class="line"> *</span><br><span class="line"> * @date Created in 2018/3/29</span><br><span class="line"> */</span><br><span class="line">public class MyTest4 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">//		MyParent4 myParent4 = new MyParent4();</span><br><span class="line">//		System.out.println(&quot;=============&quot;);</span><br><span class="line">//		MyParent4 myParent41 = new MyParent4();</span><br><span class="line"></span><br><span class="line">		MyParent4[] myParent4s = new MyParent4[1];</span><br><span class="line">		System.out.println(myParent4s.getClass());</span><br><span class="line"></span><br><span class="line">		MyParent4[][] myParent4s1 = new MyParent4[1][1];</span><br><span class="line">		System.out.println(myParent4s1.getClass());</span><br><span class="line"></span><br><span class="line">		System.out.println(myParent4s.getClass().getSuperclass());</span><br><span class="line">		System.out.println(myParent4s1.getClass().getSuperclass());</span><br><span class="line">		System.out.println(&quot;============&quot;);</span><br><span class="line"></span><br><span class="line">		int[] ints = new int[1];</span><br><span class="line">		System.out.println(ints.getClass());</span><br><span class="line">//		System.out.println(ints.getClass().getSuperclass());</span><br><span class="line">		char[] chars = new char[1];</span><br><span class="line">		System.out.println(chars.getClass());</span><br><span class="line">		short[] shorts = new short[1];</span><br><span class="line">		System.out.println(shorts.getClass());</span><br><span class="line">		float[] floats = new float[1];</span><br><span class="line">		System.out.println(floats.getClass());</span><br><span class="line">		double[] doubles = new double[1];</span><br><span class="line">		System.out.println(doubles.getClass());</span><br><span class="line">		long[] longs = new long[1];</span><br><span class="line">		System.out.println(longs.getClass());</span><br><span class="line">		boolean[] booleans = new boolean[1];</span><br><span class="line">		System.out.println(booleans.getClass());</span><br><span class="line">		byte[] bytes = new byte[1];</span><br><span class="line">		System.out.println(bytes.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4 &#123;</span><br><span class="line">	// 在类被主动使用时，才会初始化一次</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;MyParent4 static block!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载：就是把二进制形式的java类型读入到java虚拟机中；</p><p>验证：确保被加载的类的正确性；</p><p>准备：为类的变量分配内存，设置默认值，但在到达初始化之前，类的变量都没有初始化为真正的初始值；</p><p>解析：解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程；</p><p>初始化：为类的变量赋予正确的初始值；</p><p>类的实例化：</p><ul><li>为新的对象分配内存；</li><li>为实例变量赋默认值；</li><li>为实例变更赋正确的初始值；</li><li>java编译器为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被称为“<init>”，针对源代码中每一个类的构造方法，java编译器都产生一个<init>方法。</init></init></li></ul><p>类的加载的最终产品是位于内存中的Class对象；</p><p>Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口；</p><p>有两种类型的类加载器：</p><ul><li>Java虚拟机自带的加载器<ul><li>根类加载器（Bootstrap）</li><li>扩展类加载器（Extension）</li><li>系统（应用）类加载器（System）</li></ul></li><li>用户自定义的类加载器<ul><li>java.lang.ClassLoader的子类</li><li>用户可以定制类的加载方式</li></ul></li></ul><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它；</p><p>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）；</p><p>如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h4 id="类的验证"><a href="#类的验证" class="headerlink" title="类的验证"></a>类的验证</h4><ol><li>类被加载后，就进入连接阶段，连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</li><li>类的验证的内容<ul><li>类文件的结构检查；</li><li>语义检查；</li><li>字节码验证；</li><li>二进制兼容性的验证。</li></ul></li></ol><h4 id="类的准备"><a href="#类的准备" class="headerlink" title="类的准备"></a>类的准备</h4><p>在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认的初始值。如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    private static int a = 1;</span><br><span class="line">    public static long b;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><ol><li><p>在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：1）、在静态变量的声明处进行初始化；2）、在静态代码块中进行初始化。如以下代码，静态变量a和b都被显式初始化，而静态变量c没有被显式初始化，它将保持默认值0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    private static int a = 1; // 在静态变量的声明处进行初始化</span><br><span class="line">    public static long b;</span><br><span class="line">    public static long c;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        b = 2; // 在静态代码块处进行初始化</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态变量的声明语句，以及静态代码块都被看做类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行它们。如当以下Sample类被初始化后，它的静态变量a的取值为4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    static int a = 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        a = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        a = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;a=&quot; + a); // 输出a=4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的初始化步骤</p><ul><li>假如这个类还没有被加载和连接，那就先进行加载和连接；</li><li>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类；</li><li>假如类中存在初始化语句，那就按顺序依次执行这些初始化语句。</li></ul></li><li><p>类的初始化时机</p><ul><li>主动使用（七种-重要）<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如：Class.forName(“com.test.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类（Java Test）</li></ul></li><li>JDK1.7开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果 REF_getStatic，REF_pubStatic，REF_invokeStatic句柄对应的类没有初始化，则去初始化；</li><li><p>除了上述七种情形，其他使用Java类的方式都被看作是被动使用，不会导致类的初始化；</p></li><li><p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口；</li><li><p>在初始化一个接口时，并不会先初始化它的父接口。</p><p>因此，一个父接口并不会因为它的子接口或实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p></li></ul></li><li>只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用；</li><li>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li></ul></li></ol><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ol><li><p>类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开始，类的加载过程采用双（父）亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器，当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器都加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。</p></li><li><p>Java虚拟机自带了以下几种加载器：</p><ul><li>根（Bootstrap）类加载器：该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。如从例程10-4(Sample.java)可以看出，java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类；</li><li>扩展（Extension）类加载器：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类；</li><li>系统（System）类加载器：也称应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器，系统类加载器是纯Java类，是java.lang.ClassLoader类的子类；</li><li><p>除了以上虚拟机构自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p></li><li><p><strong>==用户自定义加载器 -&gt; 系统类加载器 -&gt; 扩展类加载器 -&gt; 根类加载器==</strong></p><p><img src="/2018/11/29/JVM深入解析/classLoader.png" alt="image"><br><img src="/2018/11/29/JVM深入解析/entrust.png" alt="image"></p></li></ul></li><li><p>获取ClassLoader的途径</p><ul><li><p>获得当前类的ClassLoader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader();</span><br></pre></td></tr></table></figure></li><li><p>获得当前线程上下文的ClassLoader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure></li><li><p>获得系统的ClassLoader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure></li><li><p>获得调用者的ClassLoader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader();</span><br></pre></td></tr></table></figure></li></ul></li></ol></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://www.ylliao.club/2018/11/29/JVM深入解析/" title="JVM深入解析（一）" target="_blank" rel="external">http://www.ylliao.club/2018/11/29/JVM深入解析/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/ylliao" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/ylliao" target="_blank"><span class="text-dark">廖月礼</span><small class="ml-1x">一份耕耘，一份收获</small></a></h3><div></div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom=""><div class="bar-inner"><ul class="pager pull-left"><li class="next"><a href="/2018/11/27/Apache-Kafka实战剖析/" title="Apache Kafka实战剖析（一）"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/ylliao" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/ylliao" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy;2017 - 2018 Yueli.Liao<div class="publishby"><a href="https://hexo.io" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a> Theme <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">Pure</a> by Cofess</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta="nick,mail,link";meta=meta.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html><!-- rebuild by neat -->